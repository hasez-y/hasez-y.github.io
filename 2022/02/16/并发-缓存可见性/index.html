<!-- build time:Wed Feb 16 2022 17:16:32 GMT+0800 (Hong Kong Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sakura🌸落ちるスピードは毎秒5センチメートルです" href="https://pyke.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sakura🌸落ちるスピードは毎秒5センチメートルです" href="https://pyke.top/atom.xml"><link rel="alternate" type="application/json" title="Sakura🌸落ちるスピードは毎秒5センチメートルです" href="https://pyke.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="并发,CPU"><link rel="canonical" href="https://pyke.top/2022/02/16/%E5%B9%B6%E5%8F%91-%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/"><title>并发 - 缓存可见性 | Jigds-Blog = Sakura🌸落ちるスピードは毎秒5センチメートルです = 有心栽花花不开，无心插柳柳成荫</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">并发 - 缓存可见性</h1><div class="meta"><span class="item" title="创建时间：2022-02-16 17:12:12"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-02-16T17:12:12+08:00">2022-02-16</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>4.5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>4 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jigds-Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxfdlttj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pyke.top/2022/02/16/%E5%B9%B6%E5%8F%91-%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Jigds"><meta itemprop="description" content="有心栽花花不开，无心插柳柳成荫, 记录摸鱼日常"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakura🌸落ちるスピードは毎秒5センチメートルです"></span><div class="body md" itemprop="articleBody"><h2 id="缓存可见性"><a class="anchor" href="#缓存可见性">#</a> 缓存可见性</h2><p>产生并发问题的核心原因就是多个 CPU 都有各自的缓存区域，而且他们各自之间无法感知的，当一个 CPU 对共享数据进行修改了之后，其他 CPU 并不知道内容已被修改，还是从自己缓存中读取到旧的数据。</p><p>要解决这个问题就要一种机制来保证一个人修改了内存数据后另外几个缓存了该共享数据的 CUP 可以感知，就能保证各个缓存之间的数据一致性了。</p><h2 id="总线锁"><a class="anchor" href="#总线锁">#</a> 总线锁</h2><p>如果想要每个 CPU 的缓存数据一致，那么最直接的办法就是同时只允许一个人修改内存的数据，当前面一个人操作结束之后，然后 通知其它缓存了该共享变量的缓存，通过这种串行化的方式加上通知机制来保证各个缓存之间的数据一致性，这也就是总线锁的思路。</p><p>我们所有内存的传输都发生在一条共享的总线上，同时所有的处理器都能看到这条总线，虽然缓存各自是独立的，但是主存是共享的，所有的内存访问都要经过总线类似于加锁的机制来决定 CPU 是否可以进行内存的读写，也就是说在在同一个指令周期中，只可能有一个 CPU 缓存可以读写内存。</p><p>除了总线仲裁机制外，还有一个和总线锁保证可见性的机制叫 “<strong>嗅探机制</strong>”，CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其它处理器马上知道这块内存在它们的缓存段中已失效。</p><h2 id="缓存锁"><a class="anchor" href="#缓存锁">#</a> 缓存锁</h2><p>总线锁的机制很简单思路也很清晰，通过总线加锁和嗅探机制能保证缓存数据的一致性，但是总线锁有一个比较粗暴的点让人难以忍受，当某个 CPU 对总线进行加锁之后，其它 CPU 就无法与主存建立通讯，当一个 CPU 加锁之后所有后续对主存的操作都是阻塞的，所以这种机制就必定会降低性能。</p><p>所以就需要一种优化方案，这个就是缓存锁要解决的事情，缓存锁的实现机制是通过缓存一致性协议来解决的，缓存一致性协议也有多种，比如 MESI、MOESI，这个是根据不同的操作系统和不同的硬件架构决定的，这里我们以常说的 <code>MESI</code> 协议来理解缓存锁是如何实现的。</p><h2 id="缓存一致性协议-mesi"><a class="anchor" href="#缓存一致性协议-mesi">#</a> 缓存一致性协议 MESI</h2><p>为了解决了缓存不可见问题硬件程序就制定了一套保证缓存之间可见的协议 MESI，该协议通过对共享数据进行不同状态的标识，来决定 CPU 何时把缓存的数据同步到主存，何时可以从缓存读取数据，何时又必须从主存读取数据。</p><p>MESI 每个字母就代表着一种数据状态，分别是 Modified 、Exclusive 、Share 、Invalid，每个 CPU 读取共享数据之前先要识别数据的对象状态，然后根据这几个状态分别执行不同的策略，下面我们分别了解下每个状态所代表的含义。</p><h2 id="exclusive-独占状态"><a class="anchor" href="#exclusive-独占状态">#</a> Exclusive 独占状态</h2><p>当数据 <code>Exclusive</code> 状态就是说该数据只有我一个人在用，不存在其他 CPU 修改的可能，当前缓存数据是最新的。</p><p>状态说明： <code>Exclusive</code> 代表数据处于独占状态。该状态说明此数据没有其他 CPU 缓存，只有当前 CPU 在使用，因为没有其他人使用所以也就肯定当前数据和主存是一致的，所以当 CPU 发现自己缓存中的共享数据是 <code>Exclusive</code> 状态时候就说明该数据是最新值，可以直接读取。</p><h3 id="状态改变"><a class="anchor" href="#状态改变">#</a> 状态改变</h3><p>当缓存数据处于独 <code>Exclusive</code> 态时，一旦后面有其他 CPU 缓存了该数据，那么当前数据会由 <code>Exclusive</code> 状态变为 <code>Share</code> 状态。</p><h2 id="share-共享状态"><a class="anchor" href="#share-共享状态">#</a> Share 共享状态</h2><p>当数据处于 <code>Share</code> 状态就是说当前数据有好几个人在用，但是没有被人修改过，所以当前缓存数据也是最新的。</p><p>状态说明： <code>Share</code> 代表数据处于共享状态，此状态代表数据存在于多个缓存之中，而且数据和当前主存中的数据是一致的，这也就意味着当 CPU 发现自己缓存中的共享数据是 <code>Share</code> 状态时候就说明该数据是最新值，可以直接读取。</p><h2 id="modified-修改状态"><a class="anchor" href="#modified-修改状态">#</a> Modified 修改状态</h2><p><code>Modified</code> 是一个中间状态，处于 <code>Modified</code> 状态的数据说明该数据正处于修改中，还没有同步到主存去，这个状态下数据可能和主存其它 CPU 缓存都不一致。</p><p>状态说明：当 CPU 对缓存数据进行修改时，数据变为 <code>Modified</code> 状态，并且同时会向其他缓存了该数据的 CPU 缓存发送一条 <code>Invalid</code> 指令，告诉其他缓存自己对数据进行了修改，让它们把数据置为 <code>Invalid</code> 状态； 当收到其它 CPU 缓存 <code>Invalid</code> 指令的成功响应时，当前缓存会就会把数据同步到主存里面去，然后自己的数据状态由 <code>Modified</code> 变为 <code>Exclusive</code> 状态，当有其他 CPU 缓存从主存中读取到了最新的数据时，数据状态会变为 <code>Share</code> 状态。</p><p><img data-src="https://s2.loli.net/2022/02/16/gaIePsjQDAh4MK2.png" alt=""></p><h2 id="invalid-无效状态"><a class="anchor" href="#invalid-无效状态">#</a> Invalid 无效状态</h2><p>当数据处于 <code>Invalid</code> 状态时，说明改数据已经被其它人修改过了，当前缓存数据是无效的，所以必须从主存中读取最新的数据。</p><p>状态说明： 一旦有某个 CPU 对共享的数据进行修改了，那么就会发送一条 <code>Invalid</code> 指令给其它缓存了相同数据的 CPU 缓存，收到指令的 CPU 缓存会把自己的缓存数据状态标记为 <code>Invalid</code> ，所以当数据处于 <code>Invalid</code> 时表示数据已经被别人修改了，当前数据是无效的。</p><h2 id="store-buffere"><a class="anchor" href="#store-buffere">#</a> Store Buffere</h2><p>回顾一下 MESI 协议中，在对数据进行修改的时候有几个步骤，先修改自己缓存的值 -&gt; 然后通知其它 CPU -&gt; 收到所有 CPU 的响应之后再把数据同步到主存。 如果你是一个对资源利用敏感的人肯定会发现这其中的问题，因为从修改数据然后通知 CPU、直到收到所有 CPU 响应把数据更新到缓存，整个过程都是<strong>同步</strong>进行的，CPU 发送完通知后必须同步等待所有其它 CPU 的响应，，而这个过程中当前 CPU 又无法释放出来而去干别的事情的，所以为了避免这种 CPU 运算资源的浪费，就需要一种方式来进行优化了。</p><p>这里的优化方法也很简单，只要让 CPU 发送通知之后不需要同步等待通知即可，然后就有了 <code>Store Bufferes</code> ，CPU 对某个共享变量修改时，向其他 CPU 发出 <code>Invalid</code> 指令后不同步等待其他 CPU 指令的响应了，而是直接把最新值写入到一个缓冲区也就是 <code>Store Bufferes</code> 里，然后直接可以去干别的事情了，直到所有的 CPU 都对 <code>Invalid</code> 响应后，再把共享变量的值从 <code>Store Bufferes</code> 里拿出来，写入到自己的缓存里同时同步到主存里面去。</p><h2 id="store-forward存储转发"><a class="anchor" href="#store-forward存储转发">#</a> Store Forward (存储转发)</h2><p><code>Store Bufferes</code> 的确提高了 CPU 的资源利用率，不过优化了带来了新的问题，回到上面 CPU 修改数据的第一步，如果第一步完成了之后（这个时候数据还在 <code>strore Bufferes</code> 中，自己的缓存中还是旧值），如果此时 CPU-1 接到了一个读取 a 共享变量的指令，那么 CPU 这时候会从自己的缓存中去读取共享变量的数据，而当前缓存中的数据并不是最新的，那么这是一个很明显的问题。所以没办法，要解决这个问题就必须要求 CPU 读取数据时得先看 <code>Store Buferes</code> 里面有没有，如果有则直接读取 <code>Store Buferes</code> 里的值，如果没有才能读取自己缓存里面的数据，这也就是所谓的 “ <code>Store Forward</code> ”。</p><h2 id="失效队列"><a class="anchor" href="#失效队列">#</a> 失效队列</h2><p><code>Store Buffere</code> 对写入缓存的操作进行了优化，不过 <code>Store Buffere</code> 是一块很小的空间，当指令过多 <code>Store Buffere</code> 满了之后，那么新来的指令还是得同步发送指令给其他 CPU，而 CPU 总是很忙的，如果此时收到消息的 CPU 在干其它的事情，没法即时给发消息的人回复，那么这个发消息的人就会陷入等待了，只有所有 CPU 都回复之后，再把最新的数据同步到缓存和主存里去。</p><p>所以为了避免因为接收消息的 CPU 繁忙无法即时处理 <code>Invalid</code> 失效数据的消息，而造成 CPU 指令的等待，所以就在接收 CPU 的那方也加上了一个<strong>异步消息队列</strong>，消息发送方把数据失效消息发送到这个 “失效队列里面”，然后就返回认为接收方已经恢复了，所以就可以继续执行下面的流程了，而消息接收方也可以在自己有时间的时候再来处理 “<strong>失效队列</strong>” 的消息。</p><h2 id="内存屏障"><a class="anchor" href="#内存屏障">#</a> 内存屏障</h2><p>还是 <code>Store Bufferes</code> 优化带来的问题，上面的 “ <code>Store Forward</code> ” 只解决了当前 CPU 读取数据的问题，但是并没有解决其他 CPU 读取数据的问题。还是一样，上面 CPU-1 修改数据的时候，在完成了第一步完成了之后，此时 CPU 接到了读取共享变量 a 数据的指令，就会从自己的缓存读取数据，但是很显然此时其他 CPU 缓存的共享变量 a 还是旧值，当然此时共享变量 a 的数据可能是 Invalid 的，那么就会从主存里面去查询的数据，但是不幸的是主存里面的数据也还没有更新，所以这个时候读到的数据 a 还是旧值。</p><p>这种因为 CPU 缓存优化而导致后面的指令查看不到前面指令的执行结果，就好像指令之间的执行顺序错乱了一样，这种现象也就是我们俗称的 **“CPU 乱序执行”**，<strong>那么对于这种 CPU 乱序执行导致程序执行时候读到的数据并非我们的预期数据也是造成并发问题的 BUG 来源</strong>。</p><p>那么又如何解决呢？其实也很简单，就是回到最开始的地方，<strong>禁用 CPU 缓存优化</strong>即可，<strong>修改共享数据的指令都同步完成就能保证数据的可见性了，但是这样又会降低整体的性能，这样有点得不偿失，因为毕竟大部分情况下数据都不存在这种共享的问题</strong>。不过我们必须要为这种场景提供一种手段来禁用 CPU 缓存优化，而这种手段就是<strong>内存屏障</strong>机制。</p><p>使用了<strong>内存屏障</strong>后，写入数据时候会保证所有的指令都执行完毕，这样就能保证修改过的数据能即时的暴露给其他的 CPU。在读取数据的时候保证所有的 “无效队列” 消息都已经被读取完毕，这样就保证了其他 CPU 修改的数据消息都能被当前 CPU 知道，然后根据 <code>Invalid</code> 消息判断自己的缓存是否处于无效状态，这样就读取数据的时候就能正确的读取到最新的数据。</p><h2 id="store-barrier-写屏障"><a class="anchor" href="#store-barrier-写屏障">#</a> Store Barrier 写屏障</h2><p>强制所有在 store 屏障指令之前的 store 指令，都在该 store 屏障指令执行之前被执行，并把 store 缓冲区的数据都刷到 CPU 缓存。</p><p>这个屏障的意思就是只要看到 <code>Store Barrier</code> 指令了，那么就必须把 <code>Store Barrier</code> 指令之前的所有写入指令执行完毕才可以往下执行，通过这种方式就可以让 CPU 修改的数据可以马上暴露给其他 CPU。</p><h2 id="load-barrier-读屏障"><a class="anchor" href="#load-barrier-读屏障">#</a> Load Barrier 读屏障</h2><p>强制所有在 load 屏障指令之后的 load 指令，都在该 load 屏障指令执行之后被执行，并且一直等到 load 缓冲区被该 CPU 读完才能执行之后的 load 指令。</p><p>这个指令的意思是，在 Load 屏障指令执行后就能保证后面的读取数据指令一定能读取到最新的数据。</p><h2 id="full-barrier-全能屏障"><a class="anchor" href="#full-barrier-全能屏障">#</a> Full Barrier 全能屏障</h2><p>包含了 Store Barrier 和 Load Barrier 的功能</p><h2 id="jmm-解决缓存可见性问题"><a class="anchor" href="#jmm-解决缓存可见性问题">#</a> JMM 解决缓存可见性问题</h2><p>内存屏障提供了一套解决 CPU 缓存优化而导致的顺序性和可见性问题的方案，但是由于不同的硬件系统提供给的 “内存屏障” 指令都不一样，所以作为软件开发人员来说需要熟悉每个内存屏障的指令实在没必要，所以 <code>JAVA</code> 中把不同的内存屏障指令统一进行了封装，让我们的程序员不需要关心到系统的底层，只需要关心他们的自己的程序逻辑开发和如何使用这套规范即可，而封装这套解决方案的模型就是我们常说的 <code>Java</code> 内存模型 (<strong>Java Memory Model</strong>)，也就是<strong> JMM</strong></p><div class="tags"><a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"><i class="ic i-tag"></i> 并发</a> <a href="/tags/CPU/" rel="tag"><i class="ic i-tag"></i> CPU</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-02-16 17:16:22" itemprop="dateModified" datetime="2022-02-16T17:16:22+08:00">2022-02-16</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>拿来吧你</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Jigds 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Jigds 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Jigds 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Jigds <i class="ic i-at"><em>@</em></i>Sakura🌸落ちるスピードは毎秒5センチメートルです</li><li class="link"><strong>本文链接：</strong> <a href="https://pyke.top/2022/02/16/%E5%B9%B6%E5%8F%91-%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/" title="并发 - 缓存可见性">https://pyke.top/2022/02/16/并发-缓存可见性/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/02/14/IOC-AOP/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipey84bjtj20zk0m8hdt.jpg" title="IOC &amp; AOP"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>IOC & AOP</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">缓存可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">总线锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">缓存锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-mesi"><span class="toc-number">4.</span> <span class="toc-text">缓存一致性协议 MESI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exclusive-%E7%8B%AC%E5%8D%A0%E7%8A%B6%E6%80%81"><span class="toc-number">5.</span> <span class="toc-text">Exclusive 独占状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98"><span class="toc-number">5.1.</span> <span class="toc-text">状态改变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#share-%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">6.</span> <span class="toc-text">Share 共享状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modified-%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81"><span class="toc-number">7.</span> <span class="toc-text">Modified 修改状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invalid-%E6%97%A0%E6%95%88%E7%8A%B6%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">Invalid 无效状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#store-buffere"><span class="toc-number">9.</span> <span class="toc-text">Store Buffere</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#store-forward%E5%AD%98%E5%82%A8%E8%BD%AC%E5%8F%91"><span class="toc-number">10.</span> <span class="toc-text">Store Forward (存储转发)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E9%98%9F%E5%88%97"><span class="toc-number">11.</span> <span class="toc-text">失效队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">12.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#store-barrier-%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">13.</span> <span class="toc-text">Store Barrier 写屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load-barrier-%E8%AF%BB%E5%B1%8F%E9%9A%9C"><span class="toc-number">14.</span> <span class="toc-text">Load Barrier 读屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#full-barrier-%E5%85%A8%E8%83%BD%E5%B1%8F%E9%9A%9C"><span class="toc-number">15.</span> <span class="toc-text">Full Barrier 全能屏障</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmm-%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">JMM 解决缓存可见性问题</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Jigds" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Jigds</p><div class="description" itemprop="description">记录摸鱼日常</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">31</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhc2V6LXk=" title="https:&#x2F;&#x2F;github.com&#x2F;hasez-y"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTU1MDUxMTQzMQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;550511431"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjEyMTU1Nzc4MzAuY29t" title="mailto:1215577830.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/tool" rel="section"><i class="ic i-magic"></i>工具</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/14/Red-Black-Tree-%E7%BA%A2%E9%BB%91%E6%A0%91/" title="Red-Black Tree 红黑树">Red-Black Tree 红黑树</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/24/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/" title="MySQL 存储引擎介绍">MySQL 存储引擎介绍</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/23/%E6%82%B2%E8%A7%82%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81/" title="悲观锁 &amp; 乐观锁">悲观锁 & 乐观锁</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/25/Class-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%90/" title="Class 对象解析">Class 对象解析</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/24/%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E4%B8%89%E6%9D%BF%E6%96%A7/" title="并发系统三板斧">并发系统三板斧</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/23/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="JVM 垃圾回收机制">JVM 垃圾回收机制</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/25/%E8%A7%A3%E6%9E%90-Java-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/" title="解析 Java 创建一个对象的过程">解析 Java 创建一个对象的过程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/20/HashMap-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/" title="HashMap 核心知识点">HashMap 核心知识点</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/22/JVM-%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="JVM 工作流">JVM 工作流</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2021/12/30/Replica-Set-%E5%89%AF%E6%9C%AC%E9%9B%86/" title="Replica Set 副本集">Replica Set 副本集</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Jigds @ Jigds-Blog</span></div><div class="powered-by">Sakura🌸落ちるスピードは毎秒5センチメートルです</div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/02/16/并发-缓存可见性/",favicon:{show:"鱼水同欢赴巫山",hide:"倒浇红烛夜行船"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->